{"ast":null,"code":"import _get from \"/Users/ludovicmoissinac/projet6/front/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/ludovicmoissinac/projet6/front/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/ludovicmoissinac/projet6/front/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/ludovicmoissinac/projet6/front/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/ludovicmoissinac/projet6/front/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/ludovicmoissinac/projet6/front/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ComponentFactoryResolver, Directive, EventEmitter, NgModule, Output, TemplateRef, ViewContainerRef } from '@angular/core';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * \\@docs-private\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction throwNullPortalError() {\n  throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwPortalAlreadyAttachedError() {\n  throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwPortalOutletAlreadyDisposedError() {\n  throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwUnknownPortalTypeError() {\n  throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' + 'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwNullPortalOutletError() {\n  throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwNoPortalAttachedError() {\n  throw Error('Attempting to detach a portal that is not attached to a host');\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n * @abstract\n * @template T\n */\n\n\nvar Portal = /*#__PURE__*/function () {\n  function Portal() {\n    _classCallCheck(this, Portal);\n  }\n\n  _createClass(Portal, [{\n    key: \"attach\",\n    value:\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    function attach(host) {\n      if (host == null) {\n        throwNullPortalOutletError();\n      }\n\n      if (host.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n\n      this._attachedHost = host;\n      return (\n        /** @type {?} */\n        host.attach(this)\n      );\n    }\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      /** @type {?} */\n      var host = this._attachedHost;\n\n      if (host == null) {\n        throwNoPortalAttachedError();\n      } else {\n        this._attachedHost = null;\n        host.detach();\n      }\n    }\n    /**\n     * Whether this portal is attached to a host.\n     * @return {?}\n     */\n\n  }, {\n    key: \"isAttached\",\n    get: function get() {\n      return this._attachedHost != null;\n    }\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n\n  }, {\n    key: \"setAttachedHost\",\n    value: function setAttachedHost(host) {\n      this._attachedHost = host;\n    }\n  }]);\n\n  return Portal;\n}();\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n * @template T\n */\n\n\nvar ComponentPortal = /*#__PURE__*/function (_Portal) {\n  _inherits(ComponentPortal, _Portal);\n\n  var _super = _createSuper(ComponentPortal);\n\n  /**\n   * @param {?} component\n   * @param {?=} viewContainerRef\n   * @param {?=} injector\n   * @param {?=} componentFactoryResolver\n   */\n  function ComponentPortal(component, viewContainerRef, injector, componentFactoryResolver) {\n    var _this;\n\n    _classCallCheck(this, ComponentPortal);\n\n    _this = _super.call(this);\n    _this.component = component;\n    _this.viewContainerRef = viewContainerRef;\n    _this.injector = injector;\n    _this.componentFactoryResolver = componentFactoryResolver;\n    return _this;\n  }\n\n  return ComponentPortal;\n}(Portal);\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n * @template C\n */\n\n\nvar TemplatePortal = /*#__PURE__*/function (_Portal2) {\n  _inherits(TemplatePortal, _Portal2);\n\n  var _super2 = _createSuper(TemplatePortal);\n\n  /**\n   * @param {?} template\n   * @param {?} viewContainerRef\n   * @param {?=} context\n   */\n  function TemplatePortal(template, viewContainerRef, context) {\n    var _this2;\n\n    _classCallCheck(this, TemplatePortal);\n\n    _this2 = _super2.call(this);\n    _this2.templateRef = template;\n    _this2.viewContainerRef = viewContainerRef;\n    _this2.context = context;\n    return _this2;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(TemplatePortal, [{\n    key: \"origin\",\n    get: function get() {\n      return this.templateRef.elementRef;\n    }\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n\n  }, {\n    key: \"attach\",\n    value: function attach(host) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;\n      this.context = context;\n      return _get(_getPrototypeOf(TemplatePortal.prototype), \"attach\", this).call(this, host);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this.context = undefined;\n      return _get(_getPrototypeOf(TemplatePortal.prototype), \"detach\", this).call(this);\n    }\n  }]);\n\n  return TemplatePortal;\n}(Portal);\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n * @abstract\n */\n\n\nvar BasePortalOutlet = /*#__PURE__*/function () {\n  function BasePortalOutlet() {\n    _classCallCheck(this, BasePortalOutlet);\n\n    /**\n     * Whether this host has already been permanently disposed.\n     */\n    this._isDisposed = false;\n  }\n  /**\n   * Whether this host has an attached portal.\n   * @return {?}\n   */\n\n\n  _createClass(BasePortalOutlet, [{\n    key: \"hasAttached\",\n    value: function hasAttached() {\n      return !!this._attachedPortal;\n    }\n    /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n\n  }, {\n    key: \"attach\",\n    value: function attach(portal) {\n      if (!portal) {\n        throwNullPortalError();\n      }\n\n      if (this.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n\n      if (this._isDisposed) {\n        throwPortalOutletAlreadyDisposedError();\n      }\n\n      if (portal instanceof ComponentPortal) {\n        this._attachedPortal = portal;\n        return this.attachComponentPortal(portal);\n      } else if (portal instanceof TemplatePortal) {\n        this._attachedPortal = portal;\n        return this.attachTemplatePortal(portal);\n      }\n\n      throwUnknownPortalTypeError();\n    }\n    /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      if (this._attachedPortal) {\n        this._attachedPortal.setAttachedHost(null);\n\n        this._attachedPortal = null;\n      }\n\n      this._invokeDisposeFn();\n    }\n    /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.hasAttached()) {\n        this.detach();\n      }\n\n      this._invokeDisposeFn();\n\n      this._isDisposed = true;\n    }\n    /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n\n  }, {\n    key: \"setDisposeFn\",\n    value: function setDisposeFn(fn) {\n      this._disposeFn = fn;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"_invokeDisposeFn\",\n    value: function _invokeDisposeFn() {\n      if (this._disposeFn) {\n        this._disposeFn();\n\n        this._disposeFn = null;\n      }\n    }\n  }]);\n\n  return BasePortalOutlet;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\n\n\nvar DomPortalOutlet = /*#__PURE__*/function (_BasePortalOutlet) {\n  _inherits(DomPortalOutlet, _BasePortalOutlet);\n\n  var _super3 = _createSuper(DomPortalOutlet);\n\n  /**\n   * @param {?} outletElement\n   * @param {?} _componentFactoryResolver\n   * @param {?} _appRef\n   * @param {?} _defaultInjector\n   */\n  function DomPortalOutlet(outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {\n    var _this3;\n\n    _classCallCheck(this, DomPortalOutlet);\n\n    _this3 = _super3.call(this);\n    _this3.outletElement = outletElement;\n    _this3._componentFactoryResolver = _componentFactoryResolver;\n    _this3._appRef = _appRef;\n    _this3._defaultInjector = _defaultInjector;\n    return _this3;\n  }\n  /**\n   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n   * @template T\n   * @param {?} portal Portal to be attached\n   * @return {?} Reference to the created component.\n   */\n\n\n  _createClass(DomPortalOutlet, [{\n    key: \"attachComponentPortal\",\n    value: function attachComponentPortal(portal) {\n      var _this4 = this;\n\n      /** @type {?} */\n      var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n      /** @type {?} */\n\n      var componentFactory = resolver.resolveComponentFactory(portal.component);\n      /** @type {?} */\n\n      var componentRef; // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n      // for the component (in terms of Angular's component tree, not rendering).\n      // When the ViewContainerRef is missing, we use the factory to create the component directly\n      // and then manually attach the view to the application.\n\n      if (portal.viewContainerRef) {\n        componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);\n        this.setDisposeFn(function () {\n          return componentRef.destroy();\n        });\n      } else {\n        componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n\n        this._appRef.attachView(componentRef.hostView);\n\n        this.setDisposeFn(function () {\n          _this4._appRef.detachView(componentRef.hostView);\n\n          componentRef.destroy();\n        });\n      } // At this point the component has been instantiated, so we move it to the location in the DOM\n      // where we want it to be rendered.\n\n\n      this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n      return componentRef;\n    }\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n\n  }, {\n    key: \"attachTemplatePortal\",\n    value: function attachTemplatePortal(portal) {\n      var _this5 = this;\n\n      /** @type {?} */\n      var viewContainer = portal.viewContainerRef;\n      /** @type {?} */\n\n      var viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n      viewRef.detectChanges(); // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n      // But for the DomPortalOutlet the view can be added everywhere in the DOM\n      // (e.g Overlay Container) To move the view to the specified host element. We just\n      // re-append the existing root nodes.\n\n      viewRef.rootNodes.forEach(function (rootNode) {\n        return _this5.outletElement.appendChild(rootNode);\n      });\n      this.setDisposeFn(function () {\n        /** @type {?} */\n        var index = viewContainer.indexOf(viewRef);\n\n        if (index !== -1) {\n          viewContainer.remove(index);\n        }\n      }); // TODO(jelbourn): Return locals from view.\n\n      return viewRef;\n    }\n    /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(DomPortalOutlet.prototype), \"dispose\", this).call(this);\n\n      if (this.outletElement.parentNode != null) {\n        this.outletElement.parentNode.removeChild(this.outletElement);\n      }\n    }\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n\n  }, {\n    key: \"_getComponentRootNode\",\n    value: function _getComponentRootNode(componentRef) {\n      return (\n        /** @type {?} */\n\n        /** @type {?} */\n        componentRef.hostView.rootNodes[0]\n      );\n    }\n  }]);\n\n  return DomPortalOutlet;\n}(BasePortalOutlet);\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\n\n\nvar CdkPortal = /*#__PURE__*/function (_TemplatePortal) {\n  _inherits(CdkPortal, _TemplatePortal);\n\n  var _super4 = _createSuper(CdkPortal);\n\n  /**\n   * @param {?} templateRef\n   * @param {?} viewContainerRef\n   */\n  function CdkPortal(templateRef, viewContainerRef) {\n    _classCallCheck(this, CdkPortal);\n\n    return _super4.call(this, templateRef, viewContainerRef);\n  }\n\n  return CdkPortal;\n}(TemplatePortal);\n\nCdkPortal.ɵfac = function CdkPortal_Factory(t) {\n  return new (t || CdkPortal)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n};\n\nCdkPortal.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkPortal,\n  selectors: [[\"\", \"cdk-portal\", \"\"], [\"\", \"cdkPortal\", \"\"], [\"\", \"portal\", \"\"]],\n  exportAs: [\"cdkPortal\"],\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n/** @nocollapse */\n\nCdkPortal.ctorParameters = function () {\n  return [{\n    type: TemplateRef\n  }, {\n    type: ViewContainerRef\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkPortal, [{\n    type: Directive,\n    args: [{\n      selector: '[cdk-portal], [cdkPortal], [portal]',\n      exportAs: 'cdkPortal'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.TemplateRef\n    }, {\n      type: ɵngcc0.ViewContainerRef\n    }];\n  }, null);\n})();\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\n\n\nvar CdkPortalOutlet = /*#__PURE__*/function (_BasePortalOutlet2) {\n  _inherits(CdkPortalOutlet, _BasePortalOutlet2);\n\n  var _super5 = _createSuper(CdkPortalOutlet);\n\n  /**\n   * @param {?} _componentFactoryResolver\n   * @param {?} _viewContainerRef\n   */\n  function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {\n    var _this6;\n\n    _classCallCheck(this, CdkPortalOutlet);\n\n    _this6 = _super5.call(this);\n    _this6._componentFactoryResolver = _componentFactoryResolver;\n    _this6._viewContainerRef = _viewContainerRef;\n    /**\n     * Whether the portal component is initialized.\n     */\n\n    _this6._isInitialized = false;\n    _this6.attached = new EventEmitter();\n    return _this6;\n  }\n  /**\n   * Portal associated with the Portal outlet.\n   * @return {?}\n   */\n\n\n  _createClass(CdkPortalOutlet, [{\n    key: \"portal\",\n    get: function get() {\n      return this._attachedPortal;\n    }\n    /**\n     * @param {?} portal\n     * @return {?}\n     */\n    ,\n    set: function set(portal) {\n      // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n      // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n      // and attach a portal programmatically in the parent component. When Angular does the first CD\n      // round, it will fire the setter with empty string, causing the user's content to be cleared.\n      if (this.hasAttached() && !portal && !this._isInitialized) {\n        return;\n      }\n\n      if (this.hasAttached()) {\n        _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"detach\", this).call(this);\n      }\n\n      if (portal) {\n        _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"attach\", this).call(this, portal);\n      }\n\n      this._attachedPortal = portal;\n    }\n    /**\n     * Component or view reference that is attached to the portal.\n     * @return {?}\n     */\n\n  }, {\n    key: \"attachedRef\",\n    get: function get() {\n      return this._attachedRef;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      this._isInitialized = true;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"dispose\", this).call(this);\n\n      this._attachedPortal = null;\n      this._attachedRef = null;\n    }\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n\n  }, {\n    key: \"attachComponentPortal\",\n    value: function attachComponentPortal(portal) {\n      portal.setAttachedHost(this);\n      /** @type {?} */\n\n      var viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;\n      /** @type {?} */\n\n      var componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n      /** @type {?} */\n\n\n      var ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector);\n\n      _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"setDisposeFn\", this).call(this, function () {\n        return ref.destroy();\n      });\n\n      this._attachedPortal = portal;\n      this._attachedRef = ref;\n      this.attached.emit(ref);\n      return ref;\n    }\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n\n  }, {\n    key: \"attachTemplatePortal\",\n    value: function attachTemplatePortal(portal) {\n      var _this7 = this;\n\n      portal.setAttachedHost(this);\n      /** @type {?} */\n\n      var viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n\n      _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"setDisposeFn\", this).call(this, function () {\n        return _this7._viewContainerRef.clear();\n      });\n\n      this._attachedPortal = portal;\n      this._attachedRef = viewRef;\n      this.attached.emit(viewRef);\n      return viewRef;\n    }\n  }]);\n\n  return CdkPortalOutlet;\n}(BasePortalOutlet);\n\nCdkPortalOutlet.ɵfac = function CdkPortalOutlet_Factory(t) {\n  return new (t || CdkPortalOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n};\n\nCdkPortalOutlet.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkPortalOutlet,\n  selectors: [[\"\", \"cdkPortalOutlet\", \"\"], [\"\", \"cdkPortalHost\", \"\"], [\"\", \"portalHost\", \"\"]],\n  inputs: {\n    portal: [\"cdkPortalOutlet\", \"portal\"]\n  },\n  outputs: {\n    attached: \"attached\"\n  },\n  exportAs: [\"cdkPortalOutlet\", \"cdkPortalHost\"],\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n/** @nocollapse */\n\nCdkPortalOutlet.ctorParameters = function () {\n  return [{\n    type: ComponentFactoryResolver\n  }, {\n    type: ViewContainerRef\n  }];\n};\n\nCdkPortalOutlet.propDecorators = {\n  attached: [{\n    type: Output\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkPortalOutlet, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',\n      exportAs: 'cdkPortalOutlet, cdkPortalHost',\n      inputs: ['portal: cdkPortalOutlet']\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ComponentFactoryResolver\n    }, {\n      type: ɵngcc0.ViewContainerRef\n    }];\n  }, {\n    attached: [{\n      type: Output\n    }]\n  });\n})();\n\nvar PortalModule = function PortalModule() {\n  _classCallCheck(this, PortalModule);\n};\n\nPortalModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: PortalModule\n});\nPortalModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function PortalModule_Factory(t) {\n    return new (t || PortalModule)();\n  }\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PortalModule, {\n    declarations: [CdkPortal, CdkPortalOutlet],\n    exports: [CdkPortal, CdkPortalOutlet]\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PortalModule, [{\n    type: NgModule,\n    args: [{\n      exports: [CdkPortal, CdkPortalOutlet],\n      declarations: [CdkPortal, CdkPortalOutlet]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * \\@docs-private\n */\n\n\nvar PortalInjector = /*#__PURE__*/function () {\n  /**\n   * @param {?} _parentInjector\n   * @param {?} _customTokens\n   */\n  function PortalInjector(_parentInjector, _customTokens) {\n    _classCallCheck(this, PortalInjector);\n\n    this._parentInjector = _parentInjector;\n    this._customTokens = _customTokens;\n  }\n  /**\n   * @param {?} token\n   * @param {?=} notFoundValue\n   * @return {?}\n   */\n\n\n  _createClass(PortalInjector, [{\n    key: \"get\",\n    value: function get(token, notFoundValue) {\n      /** @type {?} */\n      var value = this._customTokens.get(token);\n\n      if (typeof value !== 'undefined') {\n        return value;\n      }\n\n      return this._parentInjector.get(token, notFoundValue);\n    }\n  }]);\n\n  return PortalInjector;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nexport { DomPortalOutlet as DomPortalHost, CdkPortalOutlet as PortalHostDirective, CdkPortal as TemplatePortalDirective, BasePortalOutlet as BasePortalHost, Portal, ComponentPortal, TemplatePortal, BasePortalOutlet, DomPortalOutlet, CdkPortal, CdkPortalOutlet, PortalModule, PortalInjector };","map":{"version":3,"sources":["../../../src/cdk/portal/portal-errors.ts","../../../src/cdk/portal/portal.ts","../../../src/cdk/portal/dom-portal-outlet.ts","../../../src/cdk/portal/portal-directives.ts","../../../src/cdk/portal/portal-injector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * @docs-private\n */\nexport function throwNullPortalError() {\n  throw Error('Must provide a portal to attach');\n}\n\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * @docs-private\n */\nexport function throwPortalAlreadyAttachedError() {\n  throw Error('Host already has a portal attached');\n}\n\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * @docs-private\n */\nexport function throwPortalOutletAlreadyDisposedError() {\n  throw Error('This PortalOutlet has already been disposed');\n}\n\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * @docs-private\n */\nexport function throwUnknownPortalTypeError() {\n  throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n              'a ComponentPortal or a TemplatePortal.');\n}\n\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * @docs-private\n */\nexport function throwNullPortalOutletError() {\n  throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * @docs-private\n */\nexport function throwNoPortalAttachedError() {\n  throw Error('Attempting to detach a portal that is not attached to a host');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n    TemplateRef,\n    ViewContainerRef,\n    ElementRef,\n    ComponentRef,\n    EmbeddedViewRef,\n    Injector,\n    ComponentFactoryResolver,\n} from '@angular/core';\nimport {\n    throwNullPortalOutletError,\n    throwPortalAlreadyAttachedError,\n    throwNoPortalAttachedError,\n    throwNullPortalError,\n    throwPortalOutletAlreadyDisposedError,\n    throwUnknownPortalTypeError\n} from './portal-errors';\n\n/** Interface that can be used to generically type a class. */\nexport interface ComponentType<T> {\n  new (...args: any[]): T;\n}\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n */\nexport abstract class Portal<T> {\n  private _attachedHost: PortalOutlet | null;\n\n  /** Attach this portal to a host. */\n  attach(host: PortalOutlet): T {\n    if (host == null) {\n      throwNullPortalOutletError();\n    }\n\n    if (host.hasAttached()) {\n      throwPortalAlreadyAttachedError();\n    }\n\n    this._attachedHost = host;\n    return <T> host.attach(this);\n  }\n\n  /** Detach this portal from its host */\n  detach(): void {\n    let host = this._attachedHost;\n\n    if (host == null) {\n      throwNoPortalAttachedError();\n    } else {\n      this._attachedHost = null;\n      host.detach();\n    }\n  }\n\n  /** Whether this portal is attached to a host. */\n  get isAttached(): boolean {\n    return this._attachedHost != null;\n  }\n\n  /**\n   * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n   * the PortalOutlet when it is performing an `attach()` or `detach()`.\n   */\n  setAttachedHost(host: PortalOutlet | null) {\n    this._attachedHost = host;\n  }\n}\n\n\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nexport class ComponentPortal<T> extends Portal<ComponentRef<T>> {\n  /** The type of the component that will be instantiated for attachment. */\n  component: ComponentType<T>;\n\n  /**\n   * [Optional] Where the attached component should live in Angular's *logical* component tree.\n   * This is different from where the component *renders*, which is determined by the PortalOutlet.\n   * The origin is necessary when the host is outside of the Angular application context.\n   */\n  viewContainerRef?: ViewContainerRef | null;\n\n  /** [Optional] Injector used for the instantiation of the component. */\n  injector?: Injector | null;\n\n  /**\n   * Alternate `ComponentFactoryResolver` to use when resolving the associated component.\n   * Defaults to using the resolver from the outlet that the portal is attached to.\n   */\n  componentFactoryResolver?: ComponentFactoryResolver | null;\n\n  constructor(\n      component: ComponentType<T>,\n      viewContainerRef?: ViewContainerRef | null,\n      injector?: Injector | null,\n      componentFactoryResolver?: ComponentFactoryResolver | null) {\n    super();\n    this.component = component;\n    this.viewContainerRef = viewContainerRef;\n    this.injector = injector;\n    this.componentFactoryResolver = componentFactoryResolver;\n  }\n}\n\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nexport class TemplatePortal<C = any> extends Portal<C> {\n  /** The embedded template that will be used to instantiate an embedded View in the host. */\n  templateRef: TemplateRef<C>;\n\n  /** Reference to the ViewContainer into which the template will be stamped out. */\n  viewContainerRef: ViewContainerRef;\n\n  /** Contextual data to be passed in to the embedded view. */\n  context: C | undefined;\n\n  constructor(template: TemplateRef<C>, viewContainerRef: ViewContainerRef, context?: C) {\n    super();\n    this.templateRef = template;\n    this.viewContainerRef = viewContainerRef;\n    this.context = context;\n  }\n\n  get origin(): ElementRef {\n    return this.templateRef.elementRef;\n  }\n\n  /**\n   * Attach the the portal to the provided `PortalOutlet`.\n   * When a context is provided it will override the `context` property of the `TemplatePortal`\n   * instance.\n   */\n  attach(host: PortalOutlet, context: C | undefined = this.context): C {\n    this.context = context;\n    return super.attach(host);\n  }\n\n  detach(): void {\n    this.context = undefined;\n    return super.detach();\n  }\n}\n\n\n/** A `PortalOutlet` is an space that can contain a single `Portal`. */\nexport interface PortalOutlet {\n  /** Attaches a portal to this outlet. */\n  attach(portal: Portal<any>): any;\n\n  /** Detaches the currently attached portal from this outlet. */\n  detach(): any;\n\n  /** Performs cleanup before the outlet is destroyed. */\n  dispose(): void;\n\n  /** Whether there is currently a portal attached to this outlet. */\n  hasAttached(): boolean;\n}\n\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n */\nexport abstract class BasePortalOutlet implements PortalOutlet {\n  /** The portal currently attached to the host. */\n  protected _attachedPortal: Portal<any> | null;\n\n  /** A function that will permanently dispose this host. */\n  private _disposeFn: (() => void) | null;\n\n  /** Whether this host has already been permanently disposed. */\n  private _isDisposed: boolean = false;\n\n  /** Whether this host has an attached portal. */\n  hasAttached(): boolean {\n    return !!this._attachedPortal;\n  }\n\n  attach<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n  attach<T>(portal: TemplatePortal<T>): EmbeddedViewRef<T>;\n  attach(portal: any): any;\n\n  /** Attaches a portal. */\n  attach(portal: Portal<any>): any {\n    if (!portal) {\n      throwNullPortalError();\n    }\n\n    if (this.hasAttached()) {\n      throwPortalAlreadyAttachedError();\n    }\n\n    if (this._isDisposed) {\n      throwPortalOutletAlreadyDisposedError();\n    }\n\n    if (portal instanceof ComponentPortal) {\n      this._attachedPortal = portal;\n      return this.attachComponentPortal(portal);\n    } else if (portal instanceof TemplatePortal) {\n      this._attachedPortal = portal;\n      return this.attachTemplatePortal(portal);\n    }\n\n    throwUnknownPortalTypeError();\n  }\n\n  abstract attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n\n  abstract attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C>;\n\n  /** Detaches a previously attached portal. */\n  detach(): void {\n    if (this._attachedPortal) {\n      this._attachedPortal.setAttachedHost(null);\n      this._attachedPortal = null;\n    }\n\n    this._invokeDisposeFn();\n  }\n\n  /** Permanently dispose of this portal host. */\n  dispose(): void {\n    if (this.hasAttached()) {\n      this.detach();\n    }\n\n    this._invokeDisposeFn();\n    this._isDisposed = true;\n  }\n\n  /** @docs-private */\n  setDisposeFn(fn: () => void) {\n    this._disposeFn = fn;\n  }\n\n  private _invokeDisposeFn() {\n    if (this._disposeFn) {\n      this._disposeFn();\n      this._disposeFn = null;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ComponentFactoryResolver,\n  ComponentRef,\n  EmbeddedViewRef,\n  ApplicationRef,\n  Injector,\n} from '@angular/core';\nimport {BasePortalOutlet, ComponentPortal, TemplatePortal} from './portal';\n\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nexport class DomPortalOutlet extends BasePortalOutlet {\n  constructor(\n      /** Element into which the content is projected. */\n      public outletElement: Element,\n      private _componentFactoryResolver: ComponentFactoryResolver,\n      private _appRef: ApplicationRef,\n      private _defaultInjector: Injector) {\n    super();\n  }\n\n  /**\n   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n   * @param portal Portal to be attached\n   * @returns Reference to the created component.\n   */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n    const componentFactory = resolver.resolveComponentFactory(portal.component);\n    let componentRef: ComponentRef<T>;\n\n    // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n    // for the component (in terms of Angular's component tree, not rendering).\n    // When the ViewContainerRef is missing, we use the factory to create the component directly\n    // and then manually attach the view to the application.\n    if (portal.viewContainerRef) {\n      componentRef = portal.viewContainerRef.createComponent(\n          componentFactory,\n          portal.viewContainerRef.length,\n          portal.injector || portal.viewContainerRef.injector);\n\n      this.setDisposeFn(() => componentRef.destroy());\n    } else {\n      componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n      this._appRef.attachView(componentRef.hostView);\n      this.setDisposeFn(() => {\n        this._appRef.detachView(componentRef.hostView);\n        componentRef.destroy();\n      });\n    }\n    // At this point the component has been instantiated, so we move it to the location in the DOM\n    // where we want it to be rendered.\n    this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n\n    return componentRef;\n  }\n\n  /**\n   * Attaches a template portal to the DOM as an embedded view.\n   * @param portal Portal to be attached.\n   * @returns Reference to the created embedded view.\n   */\n  attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C> {\n    let viewContainer = portal.viewContainerRef;\n    let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n    viewRef.detectChanges();\n\n    // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n    // But for the DomPortalOutlet the view can be added everywhere in the DOM\n    // (e.g Overlay Container) To move the view to the specified host element. We just\n    // re-append the existing root nodes.\n    viewRef.rootNodes.forEach(rootNode => this.outletElement.appendChild(rootNode));\n\n    this.setDisposeFn((() => {\n      let index = viewContainer.indexOf(viewRef);\n      if (index !== -1) {\n        viewContainer.remove(index);\n      }\n    }));\n\n    // TODO(jelbourn): Return locals from view.\n    return viewRef;\n  }\n\n  /**\n   * Clears out a portal from the DOM.\n   */\n  dispose(): void {\n    super.dispose();\n    if (this.outletElement.parentNode != null) {\n      this.outletElement.parentNode.removeChild(this.outletElement);\n    }\n  }\n\n  /** Gets the root HTMLElement for an instantiated component. */\n  private _getComponentRootNode(componentRef: ComponentRef<any>): HTMLElement {\n    return (componentRef.hostView as EmbeddedViewRef<any>).rootNodes[0] as HTMLElement;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ComponentFactoryResolver,\n  ComponentRef,\n  Directive,\n  EmbeddedViewRef,\n  EventEmitter,\n  NgModule,\n  OnDestroy,\n  OnInit,\n  Output,\n  TemplateRef,\n  ViewContainerRef,\n} from '@angular/core';\nimport {BasePortalOutlet, ComponentPortal, Portal, TemplatePortal} from './portal';\n\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\n@Directive({\n  selector: '[cdk-portal], [cdkPortal], [portal]',\n  exportAs: 'cdkPortal',\n})\nexport class CdkPortal extends TemplatePortal {\n  constructor(templateRef: TemplateRef<any>, viewContainerRef: ViewContainerRef) {\n    super(templateRef, viewContainerRef);\n  }\n}\n\n/**\n * Possible attached references to the CdkPortalOutlet.\n */\nexport type CdkPortalOutletAttachedRef = ComponentRef<any> | EmbeddedViewRef<any> | null;\n\n\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\n@Directive({\n  selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',\n  exportAs: 'cdkPortalOutlet, cdkPortalHost',\n  inputs: ['portal: cdkPortalOutlet']\n})\nexport class CdkPortalOutlet extends BasePortalOutlet implements OnInit, OnDestroy {\n  /** Whether the portal component is initialized. */\n  private _isInitialized = false;\n\n  /** Reference to the currently-attached component/view ref. */\n  private _attachedRef: CdkPortalOutletAttachedRef;\n\n  constructor(\n      private _componentFactoryResolver: ComponentFactoryResolver,\n      private _viewContainerRef: ViewContainerRef) {\n    super();\n  }\n\n  /** Portal associated with the Portal outlet. */\n  get portal(): Portal<any> | null {\n    return this._attachedPortal;\n  }\n\n  set portal(portal: Portal<any> | null) {\n    // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n    // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n    // and attach a portal programmatically in the parent component. When Angular does the first CD\n    // round, it will fire the setter with empty string, causing the user's content to be cleared.\n    if (this.hasAttached() && !portal && !this._isInitialized) {\n      return;\n    }\n\n    if (this.hasAttached()) {\n      super.detach();\n    }\n\n    if (portal) {\n      super.attach(portal);\n    }\n\n    this._attachedPortal = portal;\n  }\n\n  @Output() attached: EventEmitter<CdkPortalOutletAttachedRef> =\n      new EventEmitter<CdkPortalOutletAttachedRef>();\n\n  /** Component or view reference that is attached to the portal. */\n  get attachedRef(): CdkPortalOutletAttachedRef {\n    return this._attachedRef;\n  }\n\n  ngOnInit() {\n    this._isInitialized = true;\n  }\n\n  ngOnDestroy() {\n    super.dispose();\n    this._attachedPortal = null;\n    this._attachedRef = null;\n  }\n\n  /**\n   * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n   *\n   * @param portal Portal to be attached to the portal outlet.\n   * @returns Reference to the created component.\n   */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    portal.setAttachedHost(this);\n\n    // If the portal specifies an origin, use that as the logical location of the component\n    // in the application tree. Otherwise use the location of this PortalOutlet.\n    const viewContainerRef = portal.viewContainerRef != null ?\n        portal.viewContainerRef :\n        this._viewContainerRef;\n\n    const componentFactory =\n        this._componentFactoryResolver.resolveComponentFactory(portal.component);\n    const ref = viewContainerRef.createComponent(\n        componentFactory, viewContainerRef.length,\n        portal.injector || viewContainerRef.injector);\n\n    super.setDisposeFn(() => ref.destroy());\n    this._attachedPortal = portal;\n    this._attachedRef = ref;\n    this.attached.emit(ref);\n\n    return ref;\n  }\n\n  /**\n   * Attach the given TemplatePortal to this PortlHost as an embedded View.\n   * @param portal Portal to be attached.\n   * @returns Reference to the created embedded view.\n   */\n  attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C> {\n    portal.setAttachedHost(this);\n    const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n    super.setDisposeFn(() => this._viewContainerRef.clear());\n\n    this._attachedPortal = portal;\n    this._attachedRef = viewRef;\n    this.attached.emit(viewRef);\n\n    return viewRef;\n  }\n}\n\n\n@NgModule({\n  exports: [CdkPortal, CdkPortalOutlet],\n  declarations: [CdkPortal, CdkPortalOutlet],\n})\nexport class PortalModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * @docs-private\n */\nexport class PortalInjector implements Injector {\n  constructor(\n    private _parentInjector: Injector,\n    private _customTokens: WeakMap<any, any>) { }\n\n  get(token: any, notFoundValue?: any): any {\n    const value = this._customTokens.get(token);\n\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n\n    return this._parentInjector.get<any>(token, notFoundValue);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}